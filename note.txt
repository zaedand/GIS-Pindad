<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Status Tracker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 600;
        }

        .stats-bar {
            display: flex;
            background: #f7fafc;
            padding: 15px 20px;
            gap: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            flex: 1;
            min-width: 150px;
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }

        .online { color: #48bb78; }
        .offline { color: #f56565; }

        .endpoint-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        .endpoint-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border-left: 4px solid #f56565;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .endpoint-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        .endpoint-card.online {
            border-left-color: #48bb78;
        }

        .endpoint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .endpoint-name {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2d3748;
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
        }

        .status-online {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-offline {
            background: #fed7d7;
            color: #742a2a;
        }

        .endpoint-info {
            color: #4a5568;
            line-height: 1.6;
        }

        .last-seen {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .disconnect-time {
            font-weight: 600;
            color: #e53e3e;
        }

        .controls {
            padding: 20px;
            background: #f7fafc;
            border-top: 1px solid #e2e8f0;
            text-align: center;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s;
            margin: 0 10px;
        }

        button:hover {
            transform: translateY(-1px);
        }

        .real-time {
            color: #48bb78;
            font-size: 0.9rem;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“Š Status Tracker Endpoint</h1>
            <p>Monitor status online dan waktu disconnect secara real-time</p>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-number online" id="onlineCount">0</div>
                <div class="stat-label">Online</div>
            </div>
            <div class="stat-item">
                <div class="stat-number offline" id="offlineCount">0</div>
                <div class="stat-label">Offline</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="totalCount">0</div>
                <div class="stat-label">Total Endpoint</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="avgDisconnect">-</div>
                <div class="stat-label">Rata-rata Disconnect</div>
            </div>
        </div>

        <div class="endpoint-grid" id="endpointGrid">
            <!-- Endpoint cards akan ditampilkan di sini -->
        </div>

        <div class="controls">
            <button onclick="refreshData()">ðŸ”„ Refresh Data</button>
            <button onclick="simulateStatusChange()">ðŸŽ² Simulasi Perubahan</button>
            <div class="real-time" id="lastUpdate">Terakhir diupdate: -</div>
        </div>
    </div>

    <script>
        // Data sample yang Anda berikan
        let endpointData = [
            {
                contact: '-',
                endpoint: '1081',
                status: 'Unavailable 0 of',
                timestamp: '2025-07-16 08:17:05'
            },
            {
                contact: '-',
                endpoint: '1082',
                status: 'Unavailable 0 of',
                timestamp: '2025-07-16 08:17:05'
            },
            {
                contact: '-',
                endpoint: '1083',
                status: 'Unavailable 0 of',
                timestamp: '2025-07-16 08:17:05'
            }
        ];

        // Fungsi untuk menghitung selisih waktu
        function calculateTimeDifference(timestamp) {
            const now = new Date();
            const lastSeen = new Date(timestamp);
            const diffMs = now - lastSeen;

            const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);

            if (days > 0) {
                return `${days} hari, ${hours} jam yang lalu`;
            } else if (hours > 0) {
                return `${hours} jam, ${minutes} menit yang lalu`;
            } else if (minutes > 0) {
                return `${minutes} menit, ${seconds} detik yang lalu`;
            } else {
                return `${seconds} detik yang lalu`;
            }
        }

        // Fungsi untuk menentukan apakah endpoint online atau offline
        function isOnline(status) {
            return status.toLowerCase().includes('available') && !status.toLowerCase().includes('unavailable');
        }

        // Fungsi untuk format timestamp
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleString('id-ID', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // Fungsi untuk menghitung statistik
        function calculateStats() {
            const online = endpointData.filter(item => isOnline(item.status)).length;
            const offline = endpointData.length - online;
            const total = endpointData.length;

            // Hitung rata-rata waktu disconnect untuk endpoint offline
            const offlineEndpoints = endpointData.filter(item => !isOnline(item.status));
            let avgDisconnect = '-';

            if (offlineEndpoints.length > 0) {
                const totalDisconnectMs = offlineEndpoints.reduce((sum, item) => {
                    const now = new Date();
                    const lastSeen = new Date(item.timestamp);
                    return sum + (now - lastSeen);
                }, 0);

                const avgMs = totalDisconnectMs / offlineEndpoints.length;
                const avgHours = Math.floor(avgMs / (1000 * 60 * 60));
                const avgMinutes = Math.floor((avgMs % (1000 * 60 * 60)) / (1000 * 60));

                if (avgHours > 0) {
                    avgDisconnect = `${avgHours}j ${avgMinutes}m`;
                } else {
                    avgDisconnect = `${avgMinutes}m`;
                }
            }

            return { online, offline, total, avgDisconnect };
        }

        // Fungsi untuk render endpoint cards
        function renderEndpoints() {
            const grid = document.getElementById('endpointGrid');
            const stats = calculateStats();

            // Update statistik
            document.getElementById('onlineCount').textContent = stats.online;
            document.getElementById('offlineCount').textContent = stats.offline;
            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('avgDisconnect').textContent = stats.avgDisconnect;

            // Render cards
            grid.innerHTML = endpointData.map(item => {
                const online = isOnline(item.status);
                const timeDiff = calculateTimeDifference(item.timestamp);
                const formattedTime = formatTimestamp(item.timestamp);

                return `
                    <div class="endpoint-card ${online ? 'online' : ''}">
                        <div class="endpoint-header">
                            <div class="endpoint-name">Endpoint ${item.endpoint}</div>
                            <div class="status-badge ${online ? 'status-online' : 'status-offline'}">
                                ${online ? 'Online' : 'Offline'}
                            </div>
                        </div>
                        <div class="endpoint-info">
                            <div><strong>Status:</strong> ${item.status}</div>
                            <div><strong>Contact:</strong> ${item.contact}</div>
                            <div class="last-seen">
                                <div><strong>Terakhir terlihat:</strong> ${formattedTime}</div>
                                ${!online ? `<div class="disconnect-time">Disconnect: ${timeDiff}</div>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Update waktu terakhir refresh
            document.getElementById('lastUpdate').textContent =
                `Terakhir diupdate: ${new Date().toLocaleTimeString('id-ID')}`;
        }

        // Fungsi untuk refresh data (simulasi)
        function refreshData() {
            // Dalam implementasi nyata, ini akan memanggil API
            console.log('Refreshing data...');
            renderEndpoints();
        }

        // Fungsi untuk simulasi perubahan status
        function simulateStatusChange() {
            // Randomly change some endpoints status
            const randomIndex = Math.floor(Math.random() * endpointData.length);
            const randomEndpoint = endpointData[randomIndex];

            // Toggle status
            if (isOnline(randomEndpoint.status)) {
                randomEndpoint.status = 'Unavailable 0 of';
                randomEndpoint.timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
            } else {
                randomEndpoint.status = 'Available 1 of 1';
                randomEndpoint.timestamp = new Date().toISOString().slice(0, 19).replace('T', ' ');
            }

            renderEndpoints();
        }

        // Auto refresh setiap 30 detik
        setInterval(() => {
            renderEndpoints();
        }, 30000);

        // Initial render
        renderEndpoints();
    </script>
</body>
</html>
 yg dikirim dari backend
darilogs/endpoint
{
    endpoint: '1004',
    status: 'Unavailable 0 of',
    timestamp: '2025-07-23 13:38:53'
  },
lalu dtabase/api/nodes

```


    "id": 1,
    "name": "Gedung awal",
    "ip": "192.168.195.180",
    "endpoint": "1001",
    "status": "offline",
    "coords": [
      "-8.17277200",
      "112.68504900"
    ],
    "lastPing": "-614466.097798s ago",
    "uptime": "99.90%",
    "responseTime": "Timeout",
    "description": "lantai 1",
    "last_ping_raw": "2025-07-16T03:46:31.000000Z",
    "uptime_percentage": "99.90",
    "response_time_raw": 41
  },
```

1001 => ON => 07:00
1001 => OFF => 07:10 => cari catatan off terakhir yang jam_on = null, kalo gak ada catat di tbl riwayat_off (id, endpoint, jam_off, jam_on?), kalo ada biarkan
1001 => OFF => 07:20 => cari catatan off terakhir yang jam_on = null, kalo gak ada catat di tbl riwayat_off (id, endpoint, jam_off, jam_on?), kalo ada biarkan
1001 => ON => 07:30 => => cari catatan off terakhir yang jam_on = null, kalo gak biarkan, kalo ada update jam_on

id	endpoint	jam_off	jam_on
1	1001	2025-07-24 07:00:00	2025-07-24 07:30:00		jam 07:00 ON ke OFF			jam 07:00 ON
2	1001	2025-07-24 08:00:00	2025-07-24 09:00:00		jam 08:00 ON ke OFF			jam 09:00 ON
3	1004

---------------------------------------------------------------
<?php
// Database Migration
// create_riwayat_off_table.php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('riwayat_off', function (Blueprint $table) {
            $table->id();
            $table->string('endpoint');
            $table->timestamp('jam_off');
            $table->timestamp('jam_on')->nullable();
            $table->timestamps();

            $table->index(['endpoint', 'jam_on']);
            $table->index(['endpoint', 'jam_off']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('riwayat_off');
    }
};

// Model
// app/Models/RiwayatOff.php

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Carbon\Carbon;

class RiwayatOff extends Model
{
    use HasFactory;

    protected $table = 'riwayat_off';

    protected $fillable = [
        'endpoint',
        'jam_off',
        'jam_on'
    ];

    protected $casts = [
        'jam_off' => 'datetime',
        'jam_on' => 'datetime'
    ];

    /**
     * Get duration in minutes between jam_off and jam_on
     */
    public function getDurationAttribute()
    {
        if (!$this->jam_on) {
            return null; // Still offline
        }

        return $this->jam_off->diffInMinutes($this->jam_on);
    }

    /**
     * Get formatted duration
     */
    public function getFormattedDurationAttribute()
    {
        $duration = $this->duration;
        if (!$duration) {
            return 'Masih offline';
        }

        if ($duration < 60) {
            return $duration . ' menit';
        }

        $hours = floor($duration / 60);
        $minutes = $duration % 60;

        if ($hours < 24) {
            return $minutes > 0 ? "{$hours}j {$minutes}m" : "{$hours} jam";
        }

        $days = floor($hours / 24);
        $remainingHours = $hours % 24;
        return $remainingHours > 0 ? "{$days}h {$remainingHours}j" : "{$days} hari";
    }

    /**
     * Scope to get records with null jam_on (still offline)
     */
    public function scopeStillOffline($query)
    {
        return $query->whereNull('jam_on');
    }

    /**
     * Scope to get records for specific endpoint
     */
    public function scopeForEndpoint($query, $endpoint)
    {
        return $query->where('endpoint', $endpoint);
    }

    /**
     * Get the latest offline record for an endpoint that hasn't come back online
     */
    public static function getLatestOfflineRecord($endpoint)
    {
        return self::where('endpoint', $endpoint)
                   ->whereNull('jam_on')
                   ->latest('jam_off')
                   ->first();
    }
}

// Service Class
// app/Services/DeviceHistoryService.php

<?php

namespace App\Services;

use App\Models\RiwayatOff;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

class DeviceHistoryService
{
    /**
     * Handle device status change
     */
    public function handleStatusChange($endpoint, $newStatus, $timestamp = null)
    {
        $timestamp = $timestamp ? Carbon::parse($timestamp) : Carbon::now();
        $isOnline = $this->isStatusOnline($newStatus);

        Log::info("Device status change", [
            'endpoint' => $endpoint,
            'status' => $newStatus,
            'is_online' => $isOnline,
            'timestamp' => $timestamp
        ]);

        if ($isOnline) {
            $this->handleDeviceOnline($endpoint, $timestamp);
        } else {
            $this->handleDeviceOffline($endpoint, $timestamp);
        }
    }

    /**
     * Handle device going online
     */
    private function handleDeviceOnline($endpoint, $timestamp)
    {
        // Cari catatan offline terakhir yang jam_on = null
        $latestOfflineRecord = RiwayatOff::getLatestOfflineRecord($endpoint);

        if ($latestOfflineRecord) {
            // Update jam_on untuk record offline terakhir
            $latestOfflineRecord->update([
                'jam_on' => $timestamp
            ]);

            Log::info("Updated offline record with online time", [
                'id' => $latestOfflineRecord->id,
                'endpoint' => $endpoint,
                'jam_off' => $latestOfflineRecord->jam_off,
                'jam_on' => $timestamp,
                'duration_minutes' => $latestOfflineRecord->duration
            ]);
        } else {
            Log::info("No pending offline record found for endpoint", [
                'endpoint' => $endpoint,
                'timestamp' => $timestamp
            ]);
        }
    }

    /**
     * Handle device going offline
     */
    private function handleDeviceOffline($endpoint, $timestamp)
    {
        // Cek apakah sudah ada catatan offline yang belum online (jam_on = null)
        $existingOfflineRecord = RiwayatOff::getLatestOfflineRecord($endpoint);

        if (!$existingOfflineRecord) {
            // Tidak ada catatan offline yang pending, buat baru
            $newRecord = RiwayatOff::create([
                'endpoint' => $endpoint,
                'jam_off' => $timestamp,
                'jam_on' => null
            ]);

            Log::info("Created new offline record", [
                'id' => $newRecord->id,
                'endpoint' => $endpoint,
                'jam_off' => $timestamp
            ]);
        } else {
            Log::info("Offline record already exists, skipping", [
                'existing_id' => $existingOfflineRecord->id,
                'endpoint' => $endpoint,
                'existing_jam_off' => $existingOfflineRecord->jam_off,
                'new_timestamp' => $timestamp
            ]);
        }
    }

    /**
     * Determine if status indicates device is online
     */
    private function isStatusOnline($status)
    {
        if (!$status) return false;

        $statusStr = strtolower($status);

        // Online indicators
        if (strpos($statusStr, 'not in use') !== false) return true;
        if (strpos($statusStr, 'available') !== false) return true;
        if (strpos($statusStr, 'in use') !== false) return true;
        if ($statusStr === 'online') return true;

        // Offline indicators
        if (strpos($statusStr, 'unavailable') !== false) return false;
        if (strpos($statusStr, '0 of') !== false) return false;
        if ($statusStr === 'offline') return false;

        // Default to offline for unknown status
        return false;
    }

    /**
     * Get history for an endpoint
     */
    public function getHistory($endpoint, $limit = 50)
    {
        return RiwayatOff::forEndpoint($endpoint)
                         ->latest('jam_off')
                         ->limit($limit)
                         ->get();
    }

    /**
     * Get current offline devices
     */
    public function getCurrentOfflineDevices()
    {
        return RiwayatOff::stillOffline()
                         ->with([])
                         ->get()
                         ->groupBy('endpoint')
                         ->map(function ($records) {
                             return $records->first(); // Get latest record for each endpoint
                         });
    }

    /**
     * Get statistics for an endpoint
     */
    public function getEndpointStats($endpoint, $days = 7)
    {
        $since = Carbon::now()->subDays($days);

        $records = RiwayatOff::forEndpoint($endpoint)
                             ->where('jam_off', '>=', $since)
                             ->get();

        $totalOfflineEvents = $records->count();
        $totalOfflineMinutes = $records->whereNotNull('jam_on')->sum('duration');
        $currentlyOffline = $records->whereNull('jam_on')->isNotEmpty();

        return [
            'endpoint' => $endpoint,
            'period_days' => $days,
            'total_offline_events' => $totalOfflineEvents,
            'total_offline_minutes' => $totalOfflineMinutes,
            'total_offline_formatted' => $this->formatDuration($totalOfflineMinutes),
            'currently_offline' => $currentlyOffline,
            'uptime_percentage' => $this->calculateUptimePercentage($totalOfflineMinutes, $days * 24 * 60)
        ];
    }

    /**
     * Format duration in minutes to human readable
     */
    private function formatDuration($minutes)
    {
        if (!$minutes || $minutes < 1) {
            return '0 menit';
        }

        if ($minutes < 60) {
            return $minutes . ' menit';
        }

        $hours = floor($minutes / 60);
        $remainingMinutes = $minutes % 60;

        if ($hours < 24) {
            return $remainingMinutes > 0 ? "{$hours}j {$remainingMinutes}m" : "{$hours} jam";
        }

        $days = floor($hours / 24);
        $remainingHours = $hours % 24;
        return $remainingHours > 0 ? "{$days}h {$remainingHours}j" : "{$days} hari";
    }

    /**
     * Calculate uptime percentage
     */
    private function calculateUptimePercentage($offlineMinutes, $totalMinutes)
    {
        if ($totalMinutes <= 0) return 100;

        $uptimeMinutes = $totalMinutes - $offlineMinutes;
        return round(($uptimeMinutes / $totalMinutes) * 100, 2);
    }
}

// Controller
// app/Http/Controllers/DeviceHistoryController.php

<?php

namespace App\Http\Controllers;

use App\Services\DeviceHistoryService;
use Illuminate\Http\Request;
use App\Models\RiwayatOff;

class DeviceHistoryController extends Controller
{
    protected $historyService;

    public function __construct(DeviceHistoryService $historyService)
    {
        $this->historyService = $historyService;
    }

    /**
     * Get history for specific endpoint
     */
    public function getHistory($endpoint, Request $request)
    {
        $limit = $request->get('limit', 50);
        $history = $this->historyService->getHistory($endpoint, $limit);

        return response()->json([
            'endpoint' => $endpoint,
            'history' => $history,
            'total' => $history->count()
        ]);
    }

    /**
     * Get all currently offline devices
     */
    public function getCurrentOffline()
    {
        $offlineDevices = $this->historyService->getCurrentOfflineDevices();

        return response()->json([
            'offline_devices' => $offlineDevices,
            'count' => $offlineDevices->count()
        ]);
    }

    /**
     * Get statistics for endpoint
     */
    public function getStats($endpoint, Request $request)
    {
        $days = $request->get('days', 7);
        $stats = $this->historyService->getEndpointStats($endpoint, $days);

        return response()->json($stats);
    }

    /**
     * Get all history with pagination
     */
    public function getAllHistory(Request $request)
    {
        $perPage = $request->get('per_page', 20);
        $endpoint = $request->get('endpoint');

        $query = RiwayatOff::with([])
                           ->latest('jam_off');

        if ($endpoint) {
            $query->forEndpoint($endpoint);
        }

        $history = $query->paginate($perPage);

        return response()->json($history);
    }

    /**
     * Manual status update (for testing)
     */
    public function updateStatus(Request $request)
    {
        $request->validate([
            'endpoint' => 'required|string',
            'status' => 'required|string',
            'timestamp' => 'nullable|date'
        ]);

        $this->historyService->handleStatusChange(
            $request->endpoint,
            $request->status,
            $request->timestamp
        );

        return response()->json([
            'message' => 'Status updated successfully',
            'endpoint' => $request->endpoint,
            'status' => $request->status
        ]);
    }
}

// Routes
// routes/api.php (add these routes)

/*
Route::prefix('history')->group(function () {
    Route::get('/endpoint/{endpoint}', [DeviceHistoryController::class, 'getHistory']);
    Route::get('/endpoint/{endpoint}/stats', [DeviceHistoryController::class, 'getStats']);
    Route::get('/offline', [DeviceHistoryController::class, 'getCurrentOffline']);
    Route::get('/all', [DeviceHistoryController::class, 'getAllHistory']);
    Route::post('/update-status', [DeviceHistoryController::class, 'updateStatus']);
});
*/

-------------------------
// resources/js/history-integration.js
// Add this to your existing logs.js or dashboard.js

class DeviceHistoryTracker {
    constructor() {
        this.previousStates = new Map(); // Store previous status of each endpoint
        this.historyCache = new Map();   // Cache history data
        this.init();
    }

    init() {
        console.log('Device History Tracker initialized');
    }

    /**
     * Track status change and send to backend
     */
    async handleStatusChange(endpoint, newStatus, timestamp = null) {
        try {
            const previousStatus = this.previousStates.get(endpoint);
            const currentTimestamp = timestamp || new Date().toISOString();

            // Only process if status actually changed
            if (previousStatus !== newStatus) {
                console.log(`Status change detected for ${endpoint}: ${previousStatus} â†’ ${newStatus}`);

                // Send to backend
                await this.sendStatusUpdate(endpoint, newStatus, currentTimestamp);

                // Update our local state
                this.previousStates.set(endpoint, newStatus);

                // Trigger UI updates
                this.onStatusChanged(endpoint, previousStatus, newStatus, currentTimestamp);
            }
        } catch (error) {
            console.error('Error handling status change:', error);
        }
    }

    /**
     * Send status update to backend
     */
    async sendStatusUpdate(endpoint, status, timestamp) {
        try {
            const response = await fetch('/api/history/update-status', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
                },
                body: JSON.stringify({
                    endpoint: endpoint,
                    status: status,
                    timestamp: timestamp
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            console.log('Status update sent successfully:', result);
        } catch (error) {
            console.error('Error sending status update:', error);
            // Optionally queue for retry
            this.queueRetry(endpoint, status, timestamp);
        }
    }

    /**
     * Queue failed requests for retry
     */
    queueRetry(endpoint, status, timestamp) {
        // Simple retry mechanism
        setTimeout(() => {
            this.sendStatusUpdate(endpoint, status, timestamp);
        }, 5000);
    }

    /**
     * Get history for specific endpoint
     */
    async getHistory(endpoint, limit = 50) {
        try {
            const cacheKey = `${endpoint}_${limit}`;

            // Check cache first
            if (this.historyCache.has(cacheKey)) {
                const cached = this.historyCache.get(cacheKey);
                // Cache for 5 minutes
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.data;
                }
            }

            const response = await fetch(`/api/history/endpoint/${endpoint}?limit=${limit}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            // Cache the result
            this.historyCache.set(cacheKey, {
                data: data,
                timestamp: Date.now()
            });

            return data;
        } catch (error) {
            console.error('Error fetching history:', error);
            return { endpoint, history: [], total: 0 };
        }
    }

    /**
     * Get statistics for endpoint
     */
    async getStats(endpoint, days = 7) {
        try {
            const response = await fetch(`/api/history/endpoint/${endpoint}/stats?days=${days}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching stats:', error);
            return null;
        }
    }

    /**
     * Get all currently offline devices
     */
    async getCurrentOfflineDevices() {
        try {
            const response = await fetch('/api/history/offline');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error('Error fetching offline devices:', error);
            return { offline_devices: [], count: 0 };
        }
    }

    /**
     * Initialize previous states from current nodes
     */
    initializePreviousStates(nodes) {
        nodes.forEach(node => {
            if (node.endpoint) {
                this.previousStates.set(node.endpoint, normalizeStatus(node.status));
            }
        });
        console.log('Initialized previous states for', this.previousStates.size, 'endpoints');
    }

    /**
     * Callback when status changes - override this for custom behavior
     */
    onStatusChanged(endpoint, previousStatus, newStatus, timestamp) {
        // Default implementation - you can override this
        console.log(`Device ${endpoint} status changed: ${previousStatus} â†’ ${newStatus} at ${timestamp}`);

        // Update activity log
        this.updateActivityLog(endpoint, previousStatus, newStatus, timestamp);

        // Show notification for critical changes
        if (newStatus === 'offline' && previousStatus === 'online') {
            this.showNotification(`Device ${endpoint} went offline`, 'warning');
        } else if (newStatus === 'online' && previousStatus === 'offline') {
            this.showNotification(`Device ${endpoint} came back online`, 'success');
        }
    }

    /**
     * Update activity log with status change
     */
    updateActivityLog(endpoint, previousStatus, newStatus, timestamp) {
        const logEntry = {
            endpoint: endpoint,
            previousStatus: previousStatus,
            newStatus: newStatus,
            timestamp: timestamp,
            description: this.getStatusChangeDescription(previousStatus, newStatus)
        };

        // Add to existing activity log system
        if (typeof addToActivityLog === 'function') {
            addToActivityLog(logEntry);
        }

        // Trigger activity log re-render
        if (typeof renderActivityLog === 'function') {
            renderActivityLog();
        }
    }

    /**
     * Get human-readable description of status change
     */
    getStatusChangeDescription(previousStatus, newStatus) {
        if (!previousStatus) {
            return `Device initialized as ${newStatus}`;
        }

        if (previousStatus === 'online' && newStatus === 'offline') {
            return 'Device went offline';
        }

        if (previousStatus === 'offline' && newStatus === 'online') {
            return 'Device came back online';
        }

        if (newStatus === 'partial') {
            return 'Device is now in use';
        }

        return `Status changed from ${previousStatus} to ${newStatus}`;
    }

    /**
     * Show notification to user
     */
    showNotification(message, type = 'info') {
        // Use existing notification system if available
        if (typeof showMessage === 'function') {
            showMessage(message, type);
            return;
        }

        // Fallback notification
        console.log(`[${type.toUpperCase()}] ${message}`);
    }

    /**
     * Clear cache
     */
    clearCache() {
        this.historyCache.clear();
        console.log('History cache cleared');
    }
}

// Initialize global history tracker
let deviceHistoryTracker;

// Integration with existing socket handling
function integrateHistoryWithSocket() {
    // Initialize history tracker
    deviceHistoryTracker = new DeviceHistoryTracker();

    // Initialize previous states when nodes are loaded
    if (typeof nodes !== 'undefined' && nodes.length > 0) {
        deviceHistoryTracker.initializePreviousStates(nodes);
    }

    // Hook into existing socket handler
    const originalHandleStatusUpdate = handleStatusUpdate;

    if (typeof handleStatusUpdate === 'function') {
        handleStatusUpdate = function(statusData) {
            // Call original handler
            originalHandleStatusUpdate(statusData);

            // Process each status update for history tracking
            if (Array.isArray(statusData)) {
                statusData.forEach(update => {
                    const normalizedStatus = normalizeStatus(update.status);
                    deviceHistoryTracker.handleStatusChange(
                        update.endpoint,
                        normalizedStatus,
                        update.timestamp
                    );
                });
            }
        };
    }

    // Hook into fetchNodes to initialize states
    const originalFetchNodes = fetchNodes;
    if (typeof fetchNodes === 'function') {
        fetchNodes = async function() {
            await originalFetchNodes();
            if (typeof nodes !== 'undefined') {
                deviceHistoryTracker.initializePreviousStates(nodes);
            }
        };
    }
}

// History UI Functions
class HistoryUI {
    constructor() {
        this.currentEndpoint = null;
        this.currentPage = 1;
    }

    /**
     * Show history modal for specific endpoint
     */
    async showHistoryModal(endpoint) {
        this.currentEndpoint = endpoint;

        try {
            const [history, stats] = await Promise.all([
                deviceHistoryTracker.getHistory(endpoint, 50),
                deviceHistoryTracker.getStats(endpoint, 7)
            ]);

            this.renderHistoryModal(endpoint, history, stats);
        } catch (error) {
            console.error('Error loading history:', error);
            this.showError('Failed to load history data');
        }
    }

    /**
     * Render history modal
     */
    renderHistoryModal(endpoint, historyData, statsData) {
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        modal.innerHTML = `
            <div class="bg-white rounded-lg max-w-4xl max-h-[90vh] overflow-hidden">
                <div class="p-6 border-b border-gray-200">
                    <div class="flex justify-between items-center">
                        <h2 class="text-xl font-bold">History for Endpoint ${endpoint}</h2>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-500 hover:text-gray-700">
                            <i class="fas fa-times text-xl"></i>
                        </button>
                    </div>
                </div>

                <div class="p-6 overflow-y-auto max-h-[70vh]">
                    ${this.renderStats(statsData)}
                    ${this.renderHistoryTable(historyData.history)}
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    /**
     * Render statistics section
     */
    renderStats(stats) {
        if (!stats) return '<p class="text-red-500">Failed to load statistics</p>';

        return `
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-4">7-Day Statistics</h3>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <div class="text-sm text-blue-600">Total Offline Events</div>
                        <div class="text-2xl font-bold text-blue-800">${stats.total_offline_events}</div>
                    </div>
                    <div class="bg-red-50 p-4 rounded-lg">
                        <div class="text-sm text-red-600">Total Offline Time</div>
                        <div class="text-2xl font-bold text-red-800">${stats.total_offline_formatted}</div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-lg">
                        <div class="text-sm text-green-600">Uptime</div>
                        <div class="text-2xl font-bold text-green-800">${stats.uptime_percentage}%</div>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <div class="text-sm text-gray-600">Current Status</div>
                        <div class="text-2xl font-bold ${stats.currently_offline ? 'text-red-800' : 'text-green-800'}">
                            ${stats.currently_offline ? 'Offline' : 'Online'}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Render history table
     */
    renderHistoryTable(history) {
        if (!history || history.length === 0) {
            return '<p class="text-gray-500 text-center py-8">No history data available</p>';
        }

        const rows = history.map(record => `
            <tr class="border-b border-gray-200 hover:bg-gray-50">
                <td class="py-3 px-4">${new Date(record.jam_off).toLocaleString('id-ID')}</td>
                <td class="py-3 px-4">
                    ${record.jam_on ? new Date(record.jam_on).toLocaleString('id-ID') : '<span class="text-red-500">Still offline</span>'}
                </td>
                <td class="py-3 px-4">
                    <span class="px-2 py-1 rounded-full text-xs ${record.jam_on ? 'bg-blue-100 text-blue-800' : 'bg-red-100 text-red-800'}">
                        ${record.formatted_duration || 'N/A'}
                    </span>
                </td>
            </tr>
        `).join('');

        return `
            <div>
                <h3 class="text-lg font-semibold mb-4">Offline History</h3>
                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="py-3 px-4 text-left">Offline Time</th>
                                <th class="py-3 px-4 text-left">Online Time</th>
                                <th class="py-3 px-4 text-left">Duration</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }

    /**
     * Show error message
     */
    showError(message) {
        alert('Error: ' + message); // Replace with better notification system
    }
}

// Initialize history UI
const historyUI = new HistoryUI();

// Global functions for accessing history
window.showDeviceHistory = function(endpoint) {
    historyUI.showHistoryModal(endpoint);
};

window.refreshHistoryCache = function() {
    if (deviceHistoryTracker) {
        deviceHistoryTracker.clearCache();
    }
};

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Wait a bit for other scripts to initialize
    setTimeout(() => {
        integrateHistoryWithSocket();
        console.log('History tracking integrated successfully');
    }, 1000);
});

// Export for external access
Object.assign(window, {
    deviceHistoryTracker,
    historyUI,
    integrateHistoryWithSocket
});

-------------------------

# Device History Tracking System

## Setup Instructions

### 1. Database Migration
```bash
php artisan make:migration create_riwayat_off_table
# Copy the migration code from the PHP artifact
php artisan migrate
```

### 2. Create Model and Service
```bash
# Create the RiwayatOff model
php artisan make:model RiwayatOff

# Create the DeviceHistoryService
php artisan make:service DeviceHistoryService

# Create the controller
php artisan make:controller DeviceHistoryController
```

### 3. Add Routes
Add to your `routes/api.php`:
```php
Route::prefix('history')->group(function () {
    Route::get('/endpoint/{endpoint}', [DeviceHistoryController::class, 'getHistory']);
    Route::get('/endpoint/{endpoint}/stats', [DeviceHistoryController::class, 'getStats']);
    Route::get('/offline', [DeviceHistoryController::class, 'getCurrentOffline']);
    Route::get('/all', [DeviceHistoryController::class, 'getAllHistory']);
    Route::post('/update-status', [DeviceHistoryController::class, 'updateStatus']);
});
```

### 4. Create Service Provider (Optional)
```bash
php artisan make:provider HistoryServiceProvider
```

### 5. JavaScript Integration
Include the history integration JavaScript in your existing files:
```html
<!-- Add to your layout -->
<script src="{{ mix('js/history-integration.js') }}"></script>
```

## How It Works

### Status Change Logic

#### When Device Goes OFFLINE:
1. **Check existing offline record**: Search for latest record with `jam_on = null`
2. **If no record exists**: Create new record with `jam_off = current_time`, `jam_on = null`
3. **If record exists**: Skip (device already marked as offline)

#### When Device Goes ONLINE:
1. **Find latest offline record**: Search for record with `jam_on = null`
2. **If record exists**: Update `jam_on = current_time`
3. **If no record exists**: Do nothing (device was already online)

### Example Scenarios

```
Time    | Status | Action                    | Database State
--------|--------|---------------------------|------------------------------------------
07:00   | ON     | -                        | (no records)
07:10   | OFF    | Create offline record    | ID:1, endpoint:1001, jam_off:07:10, jam_on:null
07:20   | OFF    | Skip (already offline)   | ID:1, endpoint:1001, jam_off:07:10, jam_on:null
07:30   | ON     | Update jam_on            | ID:1, endpoint:1001, jam_off:07:10, jam_on:07:30
08:00   | OFF    | Create new offline       | ID:2, endpoint:1001, jam_off:08:00, jam_on:null
09:00   | ON     | Update jam_on            | ID:2, endpoint:1001, jam_off:08:00, jam_on:09:00
```

## Usage Examples

### Backend Usage

#### In your Socket Handler or Controller:
```php
use App\Services\DeviceHistoryService;

class YourSocketController extends Controller
{
    protected $historyService;

    public function __construct(DeviceHistoryService $historyService)
    {
        $this->historyService = $historyService;
    }

    public function handleDeviceStatus($statusData)
    {
        foreach ($statusData as $device) {
            // Process each device status change
            $this->historyService->handleStatusChange(
                $device['endpoint'],
                $device['status'],
                $device['timestamp']
            );
        }
    }
}
```

#### Get History Data:
```php
// Get history for specific endpoint
$history = $historyService->getHistory('1001', 50);

// Get statistics
$stats = $historyService->getEndpointStats('1001', 7);

// Get currently offline devices
$offlineDevices = $historyService->getCurrentOfflineDevices();
```

### Frontend Usage

#### Show Device History:
```javascript
// Show history modal for specific endpoint
showDeviceHistory('1001');

// Get history programmatically
const history = await deviceHistoryTracker.getHistory('1001', 50);

// Get statistics
const stats = await deviceHistoryTracker.getStats('1001', 7);
```

#### Add History Button to Phone Cards:
```javascript
// Modify your generatePhoneCard function
function generatePhoneCard(phone) {
    return `
        <div class="bg-white rounded-xl p-4 shadow-lg">
            <!-- existing card content -->

            <div class="mt-3 flex gap-2">
                <button onclick="showDeviceHistory('${phone.endpoint}')"
                        class="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600">
                    <i class="fas fa-history mr-1"></i>
                    History
                </button>
            </div>
        </div>
    `;
}
```

## API Endpoints

### GET `/api/history/endpoint/{endpoint}`
Get history for specific endpoint
- **Parameters**: `limit` (optional, default: 50)
- **Response**:
```json
{
    "endpoint": "1001",
    "history": [
        {
            "id": 1,
            "endpoint": "1001",
            "jam_off": "2025-07-24T07:10:00.000000Z",
            "jam_on": "2025-07-24T07:30:00.000000Z",
            "duration": 20,
            "formatted_duration": "20 menit"
        }
    ],
    "total": 1
}
```

### GET `/api/history/endpoint/{endpoint}/stats`
Get statistics for endpoint
- **Parameters**: `days` (optional, default: 7)
- **Response**:
```json
{
    "endpoint": "1001",
    "period_days": 7,
    "total_offline_events": 5,
    "total_offline_minutes": 120,
    "total_offline_formatted": "2 jam",
    "currently_offline": false,
    "uptime_percentage": 98.81
}
```

### GET `/api/history/offline`
Get all currently offline devices
- **Response**:
```json
{
    "offline_devices": {
        "1001": {
            "id": 10,
            "endpoint": "1001",
            "jam_off": "2025-07-24T10:00:00.000000Z",
            "jam_on": null
        }
    },
    "count": 1
}
```

### POST `/api/history/update-status`
Manually update device status (for testing)
- **Body**:
```json
{
    "endpoint": "1001",
    "status": "offline",
    "timestamp": "2025-07-24T10:00:00.000000Z"
}
```

## Integration with Existing Code

### Update your existing socket handler:
```javascript
// In your existing handleStatusUpdate function
function handleStatusUpdate(statusData) {
    // Your existing code
    updateMapMarkers();
    updateStatusCounts();

    // Add history tracking
    if (deviceHistoryTracker) {
        statusData.forEach(update => {
            const normalizedStatus = normalizeStatus(update.status);
            deviceHistoryTracker.handleStatusChange(
                update.endpoint,
                normalizedStatus,
                update.timestamp
            );
        });
    }
}
```

### Add history buttons to your UI:
```html
<!-- In your phone monitoring table or cards -->
<button onclick="showDeviceHistory('{{ $phone->endpoint }}')"
        class="btn btn-sm btn-outline-info">
    <i class="fas fa-history"></i> History
</button>
```

## Database Schema

```sql
CREATE TABLE `riwayat_off` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `endpoint` varchar(255) NOT NULL,
  `jam_off` timestamp NOT NULL,
  `jam_on` timestamp NULL DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `riwayat_off_endpoint_jam_on_index` (`endpoint`,`jam_on`),
  KEY `riwayat_off_endpoint_jam_off_index` (`endpoint`,`jam_off`)
);
```

## Benefits

1. **Accurate Downtime Tracking**: Precisely tracks when devices go offline and come back online
2. **Prevents Duplicate Records**: Smart logic prevents creating multiple offline records for the same downtime period
3. **Real-time Updates**: Integrates seamlessly with your existing real-time system
4. **Rich Statistics**: Provides uptime percentages, total downtime, and offline event counts
5. **User-Friendly Interface**: Easy-to-use modals and buttons for viewing history
6. **API Access**: Full REST API for integration with other systems
7. **Performance Optimized**: Uses database indexes and caching for fast queries

## Troubleshooting

### Common Issues:

1. **CSRF Token Missing**: Make sure meta tag is present in your layout
2. **Socket Not Connected**: Check Socket.IO server is running on port 3000
3. **History Not Updating**: Verify the integration is called after socket data processing
4. **Database Errors**: Check migration ran successfully and indexes are created

### Debug Commands:
```bash
# Check database table
php artisan tinker
>>> App\Models\RiwayatOff::count()

# Test service manually
>>> $service = app(App\Services\DeviceHistoryService::class);
>>> $service->handleStatusChange('1001', 'offline');
>>> $service->handleStatusChange('1001', 'online');

// BAGIAN YANG PERLU DIPERBAIKI:

// 1. Fungsi getStatusDescription() - PERBAIKI INI
function getStatusDescription(fromStatus, toStatus) {
    if (toStatus === 'offline') {
        return 'Telepon tidak merespons';
    } else if (fromStatus === 'offline' && toStatus === 'online') {
        return 'Telepon kembali online';
    } else if (toStatus === 'online') {
        return 'Telepon aktif';
    } else {
        return `Status berubah dari ${fromStatus} ke ${toStatus}`;
    }
}

// 2. Fungsi trackStatusChangeAndSave() - PERBAIKI BAGIAN INI
async function trackStatusChangeAndSave(devices) {
    const statusChanges = [];

    for (const device of devices) {
        const endpoint = device.endpoint;
        const currentStatus = normalizeStatus(device.status);
        const timestamp = device.timestamp || new Date().toISOString();
        const prevStatus = previousStatusMap[endpoint];

        if (prevStatus && prevStatus !== currentStatus) {
            console.log(`[STATUS CHANGE] ${endpoint}: ${prevStatus} â†’ ${currentStatus} at ${timestamp}`);

            const node = nodes.find(n => n.endpoint === endpoint);
            const statusChangeData = {
                endpoint: endpoint, // INI YANG MENYEBABKAN MASALAH - harus hanya angka
                node_name: node?.name || `Node ${endpoint}`, // GANTI DARI "Node endpoint" ke hanya "Node angka"
                previous_status: prevStatus,
                current_status: currentStatus,
                timestamp: timestamp,
                description: getStatusDescription(prevStatus, currentStatus)
            };

            statusChanges.push(statusChangeData);

            // ... rest of the code
        }
    }
}

// 3. Fungsi loadActivityLogsFromDatabase() - PERBAIKI BAGIAN INI
async function loadActivityLogsFromDatabase() {
    try {
        const response = await fetch('/api/history/all', { headers: apiHeaders });
        if (response.ok) {
            const data = await response.json();
            const logs = Array.isArray(data) ? data : (data.data || []);

            disconnectLogs = logs.map(log => ({
                id: log.id,
                endpoint: log.endpoint,
                status: log.current_status,
                time: log.timestamp || log.created_at,
                description: log.description,
                nodeName: log.node_name || `Node ${log.endpoint}`, // GANTI DARI "Node endpoint" ke hanya "Node angka"
                duration: log.duration || null,
                from: log.previous_status,
                to: log.current_status
            }));

            calculateLogDurations();
            console.log('Loaded activity logs from database:', disconnectLogs.length);
        }
    } catch (error) {
        console.error('Error loading activity logs:', error);
    }
}

<!-- Uptime Progress Bar -->
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div class="bg-gradient-to-r ${phone.uptime >= 95 ? 'from-green-400 to-green-600' : phone.uptime >= 80 ? 'from-yellow-400 to-yellow-600' : 'from-red-400 to-red-600'} h-2 rounded-full transition-all duration-500" style="width: ${phone.uptime}%"></div>
                    </div>

1. tambah fitur search untuk mengelompokkan endpoint tertentu (misal = 1001 -> endpoint history dari 1001)
2. jika bisa, pada tabel, setiap waktu on/off diberi selisih waktu (misal 1 menit)(berfokuskan total waktu durasi offline tsb)
3. total waktu durasi offline setiap endpoint
4. beri pagination
5. yg di track/ dicatat dlm databse on ke off saja, yg off ke on biarin??
6. format waktu yang masih ada terjadi selisih waktu dengan di phonecard/server seperti'2025-07-30 09:32:51 dg 30/07/25, 16.32.51
7. pagination Log aktivitas show  10
8. jika on ke off tidak masuk ke database, duration teidak berjalan
9. filter count dari server tidak terbaca

1. beri pagination
2. optimasi fitur search

1. showToast=showNotification
2. icon dihilangkan
<<<<<<< HEAD

note: mungkin di controllernya, masalah ketika input status/jumlah telepon yang online dan offline itu diambil dari database, padahal dari realtimenya terbaca online, mungkin itu menimpa ya, apakah bisa, ketika data diekspor pada waktu tsb ketika endpoin mendapat update dari websocket, maka total status telepon diambil berdasarkan tampilan yg diterima





day
1 --
2 rancang database
3 figma
4 Frontend
-
7 memperbaiki tampilan welcome login dan register
8 mengerjakan tampilan map pada menu dashboard dengan leaflet
9  -
10 -
11 membuat crud dengan map
-
14 pengerjaan koneksi database dengan api
15 - tambah modal koneksi
16 - membuat server koneksi socket io (realtime)
18 - koneksi api ip pbx
17 - -
-
21 koneksi server, api pbx, socket
22 rancang tambah menu log history
23 Database, model, view, controller log
24 -
25 membuat fungsi input dari server ke database malalui api
-
28 me
29 menambah notif exeption koneksi
30 menambah paginaton
31 memperbaiki error server, koneksi
=======
1 membersihkan kantor, memperbaiki error koneksi, update server
4 uptime
5 menambah token koneksi ke socket server
6 melindungi route api dengan sanctum
7 menambah user role akses, sanctum & token
8 audiens presentasi projek
=======
11 menambah fitur export
12 merancang tampilan laporan
13 menambah periode waktu eksport

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use App\Models\DeviceHistory;
use App\Models\Node; // Sesuaikan dengan model Node Anda
use Carbon\Carbon;
use Illuminate\Support\Facades\Validator;
use Barryvdh\DomPDF\Facade\Pdf;

class HistoryController extends Controller
{
    // ... existing methods ...

    /**
     * Get latest status for each endpoint from history table
     */
    private function getLatestStatusStatistics(): array
    {
        // Get latest status for each endpoint
        $latestStatuses = DeviceHistory::select('endpoint', 'current_status', 'timestamp')
            ->whereIn('id', function($query) {
                $query->select(\DB::raw('MAX(id)'))
                    ->from('device_histories')
                    ->groupBy('endpoint');
            })
            ->get();

        $totalNodes = $latestStatuses->count();
        $onlineNodes = $latestStatuses->where('current_status', 'online')->count();
        $offlineNodes = $latestStatuses->where('current_status', 'offline')->count();
        $partialNodes = $latestStatuses->where('current_status', 'partial')->count();

        $onlinePercentage = $totalNodes > 0 ? round(($onlineNodes / $totalNodes) * 100, 1) : 0;
        $offlinePercentage = $totalNodes > 0 ? round(($offlineNodes / $totalNodes) * 100, 1) : 0;

        return [
            'total_nodes' => $totalNodes,
            'online_nodes' => $onlineNodes,
            'offline_nodes' => $offlineNodes,
            'partial_nodes' => $partialNodes,
            'online_percentage' => $onlinePercentage,
            'offline_percentage' => $offlinePercentage,
            'latest_statuses' => $latestStatuses
        ];
    }

    /**
     * Alternative method using subquery for better performance
     */
    private function getLatestStatusStatisticsOptimized(): array
    {
        $latestStatuses = \DB::table('device_histories as dh1')
            ->select('dh1.endpoint', 'dh1.current_status', 'dh1.timestamp', 'dh1.node_name')
            ->whereRaw('dh1.timestamp = (
                SELECT MAX(dh2.timestamp) 
                FROM device_histories dh2 
                WHERE dh2.endpoint = dh1.endpoint
            )')
            ->groupBy('dh1.endpoint', 'dh1.current_status', 'dh1.timestamp', 'dh1.node_name')
            ->get();

        $totalNodes = $latestStatuses->count();
        $onlineNodes = $latestStatuses->where('current_status', 'online')->count();
        $offlineNodes = $latestStatuses->where('current_status', 'offline')->count();
        $partialNodes = $latestStatuses->where('current_status', 'partial')->count();

        $onlinePercentage = $totalNodes > 0 ? round(($onlineNodes / $totalNodes) * 100, 1) : 0;
        $offlinePercentage = $totalNodes > 0 ? round(($offlineNodes / $totalNodes) * 100, 1) : 0;

        return [
            'total_nodes' => $totalNodes,
            'online_nodes' => $onlineNodes,
            'offline_nodes' => $offlineNodes,
            'partial_nodes' => $partialNodes,
            'online_percentage' => $onlinePercentage,
            'offline_percentage' => $offlinePercentage,
            'latest_statuses' => $latestStatuses
        ];
    }

    /**
     * Modified exportPdf method with history-based statistics
     */
    public function exportPdf(Request $request)
    {
        try {
            // ... existing validation code ...

            $validator = Validator::make($request->all(), [
                'date_method' => 'string|in:preset,custom',
                'start_date' => 'nullable|date|required_if:date_method,custom',
                'end_date' => 'nullable|date|required_if:date_method,custom|after_or_equal:start_date',
                'period' => 'nullable|integer|min:1|max:365',
                'quarter' => 'string|in:I,II,III,IV',
                'year' => 'integer|min:2020|max:2030',
                'report_type' => 'string|in:summary,detailed,kpi',
                'include_charts' => 'string|in:true,false',
                'include_ranking' => 'string|in:true,false',
                'include_history' => 'string|in:true,false',
                'include_recommendations' => 'string|in:true,false',
                'timeframe' => 'string|in:days,from_start,quarter'
            ]);

            if ($validator->fails()) {
                return response()->json([
                    'error' => 'Invalid parameters',
                    'messages' => $validator->errors()
                ], 400);
            }

            // Get and process parameters
            $dateMethod = $request->get('date_method', 'preset');
            $reportType = $request->get('report_type', 'summary');
            $quarter = $request->get('quarter', 'IV');
            $year = $request->get('year', date('Y'));

            // Determine date range based on method
            if ($dateMethod === 'custom') {
                $startDate = Carbon::parse($request->get('start_date'));
                $endDate = Carbon::parse($request->get('end_date'))->endOfDay();
                $period = $startDate->diffInDays($endDate) + 1;
            } else {
                $period = (int) $request->get('period', 30);
                $timeframe = $request->get('timeframe', 'days');

                switch ($timeframe) {
                    case 'from_start':
                        $startDate = Carbon::create($year, 1, 1)->startOfDay();
                        $endDate = Carbon::now()->endOfDay();
                        break;
                    case 'quarter':
                        [$startDate, $endDate] = $this->getQuarterDateRange($quarter, $year);
                        break;
                    case 'days':
                    default:
                        $endDate = Carbon::now()->endOfDay();
                        $startDate = Carbon::now()->subDays($period - 1)->startOfDay();
                        break;
                }
            }

            // Validate date range
            $daysDiff = round($startDate->diffInDays($endDate) + 1);
            if ($daysDiff > 365) {
                return response()->json([
                    'error' => 'Date range too large',
                    'message' => 'Maximum date range is 365 days'
                ], 400);
            }

            // Get report options
            $includeCharts = $request->get('include_charts', 'true') === 'true';
            $includeRanking = $request->get('include_ranking', 'true') === 'true';
            $includeHistory = $request->get('include_history', 'false') === 'true';
            $includeRecommendations = $request->get('include_recommendations', 'false') === 'true';

            // *** MODIFIED: Get current status from history instead of nodes table ***
            $currentStats = $this->getLatestStatusStatisticsOptimized();
            
            $totalNodes = $currentStats['total_nodes'];
            $onlineNodes = $currentStats['online_nodes'];
            $offlineNodes = $currentStats['offline_nodes'];
            $partialNodes = $currentStats['partial_nodes'];
            $onlinePercentage = $currentStats['online_percentage'];
            $offlinePercentage = $currentStats['offline_percentage'];

            // Get period-specific data
            $periodStats = $this->getPeriodStatistics($startDate, $endDate);
            $frequentlyOfflineEndpoints = $this->getFrequentlyOfflineEndpoints($startDate, $endDate, 10);
            
            // *** MODIFIED: Use history-based data for endpoints ***
            $endpointsData = $this->generateEndpointsDataFromHistory($currentStats['latest_statuses'], $startDate, $endDate);
            $rankingData = $includeRanking ? $this->generateRankingDataFromHistory($currentStats['latest_statuses'], $startDate, $endDate) : [];
            $historyData = $includeHistory ? $this->generateHistoryData($startDate, $endDate) : [];
            
            // *** MODIFIED: Calculate average uptime from history data ***
            $avgUptime = $this->calculateAverageUptimeFromHistory($currentStats['latest_statuses'], $startDate, $endDate);
            
            $recommendations = $includeRecommendations ? $this->generateRecommendations($endpointsData, $periodStats) : [];

            // Prepare report data
            $reportData = [
                // KPI Information
                'indikator' => 'KPI-TI-001',
                'nama_indikator' => 'Availability Sistem Telepon Internal',
                'formula' => '(Total Waktu Online / Total Waktu Monitoring) Ã— 100%',
                'target' => 'â‰¥ 95%',
                'realisasi' => $avgUptime . '%',
                'status_kpi' => $avgUptime >= 95 ? 'TERCAPAI' : 'TIDAK TERCAPAI',

                // Report metadata
                'report_type' => $reportType,
                'date_method' => $dateMethod,
                'quarter' => $quarter,
                'year' => $year,
                'period_days' => $daysDiff,
                'generated_date' => Carbon::now()->format('d/m/Y H:i:s'),
                'start_date' => $startDate->format('d/m/Y'),
                'end_date' => $endDate->format('d/m/Y'),
                'start_date_long' => $startDate->locale('id')->translatedFormat('l, j F Y'),
                'end_date_long' => $endDate->locale('id')->translatedFormat('l, j F Y'),

                // Current statistics (from history table)
                'total_phones' => $totalNodes,
                'online_phones' => $onlineNodes,
                'offline_phones' => $offlineNodes,
                'partial_phones' => $partialNodes,
                'online_percentage' => $onlinePercentage,
                'offline_percentage' => $offlinePercentage,
                'avg_uptime' => $avgUptime,

                // Period statistics
                'period_stats' => $periodStats,
                'frequently_offline' => $frequentlyOfflineEndpoints,

                // Data tables
                'endpoints_data' => $endpointsData,
                'ranking_data' => $rankingData,
                'history_data' => $historyData,
                'recommendations' => $recommendations,

                // Report options
                'include_charts' => $includeCharts,
                'include_ranking' => $includeRanking,
                'include_history' => $includeHistory,
                'include_recommendations' => $includeRecommendations,

                // Report signature
                'prepared_by' => 'Sistem Monitoring Telepon',
                'position' => 'Admin IT',
                'department' => 'Departemen Teknologi Informasi'
            ];

            // Select appropriate view based on report type
            $viewName = match($reportType) {
                'detailed' => 'reports.phone-status-detailed-pdf',
                'kpi' => 'reports.phone-status-kpi-pdf',
                default => 'reports.phone-status-pdf'
            };

            // Generate PDF
            $pdf = Pdf::loadView($viewName, $reportData);

            // Configure PDF settings based on report type
            $orientation = $reportType === 'detailed' ? 'landscape' : 'portrait';
            $pdf->setPaper('A4', $orientation);
            $pdf->setOptions([
                'dpi' => 150,
                'defaultFont' => 'DejaVu Sans',
                'isRemoteEnabled' => true,
                'isHtml5ParserEnabled' => true,
                'chroot' => public_path(),
            ]);

            // Generate filename
            $filename = $this->generatePdfFilename($reportData);

            return $pdf->download($filename);

        } catch (\Exception $e) {
            \Log::error('PDF Export Error: ' . $e->getMessage(), [
                'trace' => $e->getTraceAsString(),
                'request_data' => $request->all()
            ]);

            return response()->json([
                'error' => 'Failed to generate PDF report',
                'message' => $e->getMessage(),
                'code' => $e->getCode()
            ], 500);
        }
    }

    /**
     * Generate endpoints data from history table
     */
    private function generateEndpointsDataFromHistory($latestStatuses, $startDate, $endDate): array
    {
        $endpointsData = [];

        foreach ($latestStatuses as $status) {
            $uptimeData = $this->calculateRealUptime($status->endpoint, $startDate, $endDate);
            $statistics = $this->getEndpointStatistics($status->endpoint, $startDate, $endDate);
            $totalOffline = $this->getTotalOfflineDuration($status->endpoint, $startDate, $endDate);

            // Try to get building name from nodes table, fallback to node_name from history
            $node = Node::where('endpoint', $status->endpoint)->first();
            $buildingName = $node ? $node->name : $status->node_name;
            $ipAddress = $node ? $node->ip_address : 'Unknown';

            $endpointsData[] = [
                'endpoint' => $status->endpoint,
                'building' => $buildingName ?? 'Unknown',
                'ip_address' => $ipAddress,
                'current_status' => $this->formatStatus($status->current_status),
                'last_update' => Carbon::parse($status->timestamp)->format('d/m/Y H:i:s'),
                'uptime_period' => $uptimeData['uptimePercentage'] . '%',
                'total_offline_duration' => $totalOffline['formatted'],
                'total_events' => $statistics['total_events'],
                'offline_events' => $statistics['offline_events'],
                'online_events' => $statistics['online_events'],
                'reliability_score' => $this->calculateReliabilityScore($uptimeData['uptimePercentage'], $statistics['offline_events'])
            ];
        }

        // Sort by reliability score (lowest first to show problematic ones first)
        usort($endpointsData, function($a, $b) {
            return $a['reliability_score'] - $b['reliability_score'];
        });

        return $endpointsData;
    }

    /**
     * Generate ranking data from history table
     */
    private function generateRankingDataFromHistory($latestStatuses, $startDate, $endDate)
    {
        $rankingData = [];

        foreach ($latestStatuses as $status) {
            $uptimeData = $this->calculateRealUptime($status->endpoint, $startDate, $endDate);
            $statistics = $this->getEndpointStatistics($status->endpoint, $startDate, $endDate);
            $totalOfflineDuration = $this->getTotalOfflineDuration($status->endpoint, $startDate, $endDate);

            // Only include endpoints that have had offline events
            if ($statistics['offline_events'] > 0) {
                // Try to get building name from nodes table, fallback to node_name from history
                $node = Node::where('endpoint', $status->endpoint)->first();
                $buildingName = $node ? $node->name : $status->node_name;

                $rankingData[] = [
                    'endpoint' => $status->endpoint,
                    'building' => $buildingName ?? 'Unknown',
                    'current_status' => $this->formatStatus($status->current_status),
                    'uptime_period' => $uptimeData['uptimePercentage'] . '%',
                    'total_offline_duration' => $totalOfflineDuration['formatted'],
                    'total_events' => $statistics['total_events'],
                    'offline_events' => $statistics['offline_events'],
                    'online_events' => $statistics['online_events'],
                    'last_activity' => Carbon::parse($status->timestamp)->format('d/m/Y H:i:s'),
                    'offline_score' => $statistics['offline_events'] // For sorting
                ];
            }
        }

        // Sort by offline events (descending - most problematic first)
        usort($rankingData, function($a, $b) {
            return $b['offline_score'] - $a['offline_score'];
        });

        // Add ranking numbers
        foreach ($rankingData as $index => &$data) {
            $data['rank'] = $index + 1;
        }

        return array_slice($rankingData, 0, 20); // Top 20 most problematic
    }

    /**
     * Calculate average uptime from history data
     */
    private function calculateAverageUptimeFromHistory($latestStatuses, $startDate, $endDate): float
    {
        $totalUptime = 0;
        $nodeCount = 0;

        foreach ($latestStatuses as $status) {
            $uptimeData = $this->calculateRealUptime($status->endpoint, $startDate, $endDate);
            if ($uptimeData['dataAvailable']) {
                $totalUptime += $uptimeData['uptimePercentage'];
                $nodeCount++;
            }
        }

        return $nodeCount > 0 ? round($totalUptime / $nodeCount, 1) : 0;
    }

    /**
     * Get currently offline devices from history table
     * GET /api/history/offline
     */
    public function getCurrentOfflineFromHistory(): JsonResponse
    {
        try {
            $currentStats = $this->getLatestStatusStatisticsOptimized();
            
            $offlineDevices = $currentStats['latest_statuses']
                ->where('current_status', 'offline')
                ->map(function($status) {
                    return [
                        'endpoint' => $status->endpoint,
                        'node_name' => $status->node_name,
                        'current_status' => $status->current_status,
                        'last_update' => Carbon::parse($status->timestamp)->format('d/m/Y H:i:s'),
                        'duration_offline' => Carbon::parse($status->timestamp)->diffForHumans(Carbon::now(), true)
                    ];
                })
                ->values()
                ->toArray();

            return response()->json([
                'total_offline' => count($offlineDevices),
                'offline_devices' => $offlineDevices
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Failed to fetch offline devices from history',
                'message' => $e->getMessage()
            ], 500);
        }
    }

    // ... rest of existing methods remain the same ...
}
